using System;
using Microsoft.AspNetCore.Components;


namespace CompQComponents.Lib.Components
{
    public class Surrogate : ComponentBase
    {
        [Parameter] public QComponent? QComponent { get; set; }

        protected override void OnParametersSet()
        {
            QComponent?.Set(this);
        }

        private RenderFragment? result;

        public RenderFragment? RequestContent => GetContent;
        
        /// <summary>
        /// Provides the render fragment generated by the QComponent helper class
        /// </summary>
        protected virtual RenderFragment? GetContent
        {
            get
            {
                QComponent!.HasRendered = true;
                //if RenderComponent returns null, we provide the cached result.
                //else, return the returned result from the RenderComponent call.
                result = RenderComponent(out string? message) ?? result;
                if(message != null) Console.WriteLine(message);
                return result;
            }
        }

        /// <summary>
        /// Provides the RenderFragment of this component.
        /// If the component is flagged to provide a message, it is assigned to the out variable of 'message'.
        /// If the cache bool is set, then the cached item is returned instead of generating a new RenderFragment.
        /// </summary>
        /// <param name="message"></param>
        /// <returns></returns>
        public RenderFragment? RenderComponent(out string? message)
        {
            string name = QComponent!.Id;
            
            bool cache = false;
            
            //If the QComponent.Key differs from Key, execute this enclosure.
            if (cache = (Key != QComponent?.Key))
            {
                //fragment was either provided as a cached fragment, or it was re-rendered.
                message = QComponent!.LogCache ? @$"{name}: Triggered: {(QComponent.DEFAULT_KEY.Equals(QComponent.Key) ? "Initial Cache" : "ReCached")}" : null;
                Key = QComponent.Key;
                return ChildContent;
            }
           
            //If this point is reached, and Key is null, we provide ChildContent still.
            //The reason this if statement exists is due to the nature of checking the QComponent.Key, and the return sequence.
            //It could be more optimal, maybe, but it isn't necessary to condense more than we already have.
            if(cache = (Key is null))
            {
                //log if fragment was re-rendered.
                message = QComponent!.LogCache ? $"{name}: NullKey: ReCached" : null;
                return ChildContent;
            }

            if (!cache)
            {
                //output the message if flagged to log whether the fragment was cached or not.
                if(QComponent!.LogCache)
                    message = $"{name}: Cached";
            }

            message = null;
            return null;
        }
        
        protected object? Key;

        /// <summary>
        /// Virtual ChildContent 
        /// </summary>
        public virtual RenderFragment ChildContent
        {
            get => QComponent!.BuildElement();
            set {}
        }

        /// <summary>
        /// Bringing the visibibility of StateHasChanged to public. (Which, in my opinion, should have been the default visibility of the base framework anyway...
        /// </summary>
        public void ChangeState()
        {
            StateHasChanged();
        }

        /// <summary>
        /// Same as ChangeState, but this is for Server Side Blazor.
        /// </summary>
        public void InvokeAsync() => base.InvokeAsync(StateHasChanged);
    }
}